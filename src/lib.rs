#[cfg(test)]
extern crate ethabi;
extern crate crypto;
extern crate ethereum_types;
extern crate evm;
extern crate parity_bytes as bytes;
extern crate primitive_types;
extern crate vm;

mod pure_ext;

use ethereum_types::Address;
use evm::factory::Factory as EvmFactory;
use primitive_types::{H256, U256};
use pure_ext::PureExt;
use std::sync::Arc;

#[cfg(test)]
#[macro_use]
extern crate hex_literal;

pub type Result<T> = vm::Result<T>;

/// Returns the result of calling `data` on the given `code.
///
/// `code` takes the deployed code *not* initcode.
/// `data` is the normal transaction for calling a function, i.e.,
///        the sighash followed by abi-encoded arguments.
///
/// Assumes the function being called is a pure function.
pub fn exec(code: Vec<u8>, data: Vec<u8>) -> vm::Result<Vec<u8>> {
    let params = pure_action_params(code, data);
    let schedule = evm::Schedule::new_constantinople();

    let evm = {
        let depth = 1;
        let factory = EvmFactory::new(Default::default());
        factory.create(params.clone(), &schedule, depth)
    };

    let mut ext = PureExt::new(&schedule);

    let result = evm.exec(&mut ext);

    match result {
        Ok(r) => match r? {
            vm::GasLeft::NeedsReturn {
                gas_left: _,
                data,
                apply_state: _,
            } => Ok(data.to_vec()),
            _ => return Err(vm::Error::Internal("Invalid execution".to_string())),
        },
        Err(_) => return Err(vm::Error::Internal("Invalid execution".to_string())),
    }
}

fn pure_action_params(code: Vec<u8>, data: Vec<u8>) -> vm::ActionParams {
    let code_address = Address::zero();
    let code_hash: Option<H256> = None;
    let address = Address::zero();
    let sender = Address::zero();
    let origin = Address::zero();
    let gas: U256 = 50_000_000.into();
    let gas_price = U256::zero();
    let value = vm::ActionValue::Transfer(0.into());
    let code = Some(Arc::new(code));
    let data = Some(data);
    let action_type = vm::ActionType::Call;
    let params_type = vm::ParamsType::Separate;
    let code_version = U256::zero();

    vm::ActionParams {
        code_address,
        code_hash,
        address,
        sender,
        origin,
        gas,
        gas_price,
        value,
        code,
        code_version,
        data,
        action_type,
        params_type,
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn add_0_3() {
        let result = call_add_three(ethabi::Uint::from(0));
        assert_eq!(ethabi::Uint::from(3), result);
    }

    #[test]
    fn add_4_3() {
        let result = call_add_three(ethabi::Uint::from(4));
        assert_eq!(ethabi::Uint::from(7), result);
    }

    #[test]
    fn call_sha_precompile() {
        call_simple_hash();
    }

    #[test]
    fn call_recover_precompile() {
        call_simple_recover();
    }

    // Executes a call to the following function:
    // pragma solidity ^0.6.4;
    // contract SimpleHash {
    //     function hash(bytes memory toHash) public pure returns (bytes32) {
    //         return sha256(toHash);
    //     }
    // }
    fn call_simple_hash() {
        let deployed_bytecode = hex!("608060405234801561001057600080fd5b506004361061002b5760003560e01c8063aa1e84de14610030575b600080fd5b6100e96004803603602081101561004657600080fd5b810190808035906020019064010000000081111561006357600080fd5b82018360208201111561007557600080fd5b8035906020019184600183028401116401000000008311171561009757600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505091929192905050506100ff565b6040518082815260200191505060405180910390f35b60006002826040518082805190602001908083835b602083106101375780518252602082019150602081019050602083039250610114565b6001836020036101000a038019825116818451168082178552505050505050905001915050602060405180830381855afa158015610179573d6000803e3d6000fd5b5050506040513d602081101561018e57600080fd5b8101908080519060200190929190505050905091905056fea2646970667358221220419ad886521e3b4d237dee58bc2a0ce4e93dd96342ed34753ec7162b1c4da8b264736f6c63430006040033").to_vec();

        // toHash = "0xabcd"
        let method_data = hex!("aa1e84de00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002abcd000000000000000000000000000000000000000000000000000000000000").to_vec();

        let result = exec(deployed_bytecode, method_data).unwrap();

        assert_eq!(result.len(), 32)
    }

    // Executes a call to the following function
    // pragma solidity ^0.6.4;
    // import "@openzeppelin/contracts/cryptography/ECDSA.sol";
    // contract SimpleRecover {
    //     function recover(bytes memory signature, bytes32 digest)
    //         public
    //         pure
    //         returns (address)
    //     {
    //         return ECDSA.recover(digest, signature);
    //     }
    // }
    fn call_simple_recover() {
      let deployed_bytecode = hex!("608060405234801561001057600080fd5b506004361061002b5760003560e01c806351c2e54114610030575b600080fd5b61004a6004803603810190610045919061052b565b610060565b6040516100579190610898565b60405180910390f35b606061006a61023a565b858581019061007991906105c9565b9050610083610270565b848481019061009291906105a0565b90506000600282600001516040516020016100ad919061087d565b6040516020818303038152906040526040516100c99190610866565b602060405180830381855afa1580156100e6573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906101099190610502565b9050826060015115610150576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610147906108ba565b60405180910390fd5b80836020015114610196576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161018d906108da565b60405180910390fd5b82600001516000600281106101a757fe5b60200201516020015183600001516001600281106101c157fe5b60200201516020018181525050600083600001516000600281106101e157fe5b60200201516020018181525050816000015183604001818152505060018360600190151590811515815250508260405160200161021e91906108fa565b6040516020818303038152906040529350505050949350505050565b604051806080016040528061024d610286565b815260200160008019168152602001600080191681526020016000151581525090565b6040518060200160405280600080191681525090565b60405180604001604052806002905b61029d6102b3565b8152602001906001900390816102955790505090565b6040518060400160405280600073ffffffffffffffffffffffffffffffffffffffff168152602001600081525090565b6000813590506102f281610a5f565b92915050565b600082601f83011261030957600080fd5b600261031c61031782610942565b610915565b9150818385604084028201111561033257600080fd5b60005b83811015610362578161034888826104a1565b845260208401935060408301925050600181019050610335565b5050505092915050565b60008135905061037b81610a76565b92915050565b60008135905061039081610a8d565b92915050565b6000815190506103a581610a8d565b92915050565b60008083601f8401126103bd57600080fd5b8235905067ffffffffffffffff8111156103d657600080fd5b6020830191508360018202830111156103ee57600080fd5b9250929050565b60006020828403121561040757600080fd5b6104116020610915565b9050600061042184828501610381565b60008301525092915050565b600060e0828403121561043f57600080fd5b6104496080610915565b90506000610459848285016102f8565b600083015250608061046d84828501610381565b60208301525060a061048184828501610381565b60408301525060c06104958482850161036c565b60608301525092915050565b6000604082840312156104b357600080fd5b6104bd6040610915565b905060006104cd848285016102e3565b60008301525060206104e1848285016104ed565b60208301525092915050565b6000813590506104fc81610aa4565b92915050565b60006020828403121561051457600080fd5b600061052284828501610396565b91505092915050565b6000806000806040858703121561054157600080fd5b600085013567ffffffffffffffff81111561055b57600080fd5b610567878288016103ab565b9450945050602085013567ffffffffffffffff81111561058657600080fd5b610592878288016103ab565b925092505092959194509250565b6000602082840312156105b257600080fd5b60006105c0848285016103f5565b91505092915050565b600060e082840312156105db57600080fd5b60006105e98482850161042d565b91505092915050565b60006105fe8383610828565b60408301905092915050565b610613816109c9565b82525050565b6106228161096e565b61062c8184610991565b925061063782610964565b8060005b8381101561066857815161064f87826105f2565b965061065a83610984565b92505060018101905061063b565b505050505050565b610679816109db565b82525050565b610688816109e7565b82525050565b610697816109e7565b82525050565b60006106a882610979565b6106b2818561099c565b93506106c2818560208601610a1b565b6106cb81610a4e565b840191505092915050565b60006106e182610979565b6106eb81856109ad565b93506106fb818560208601610a1b565b80840191505092915050565b60006107146025836109b8565b91507f43616e6e6f742074616b6520616374696f6e206f6e2066696e616c697a65642060008301527f73746174650000000000000000000000000000000000000000000000000000006020830152604082019050919050565b600061077a6039836109b8565b91507f486173682067656e6572617465642066726f6d20707265696d61676520646f6560008301527f73206e6f74206d61746368206861736820696e207374617465000000000000006020830152604082019050919050565b60e0820160008201516107e96000850182610619565b5060208201516107fc608085018261067f565b50604082015161080f60a085018261067f565b50606082015161082260c0850182610670565b50505050565b60408201600082015161083e600085018261060a565b5060208201516108516020850182610857565b50505050565b61086081610a11565b82525050565b600061087282846106d6565b915081905092915050565b6000602082019050610892600083018461068e565b92915050565b600060208201905081810360008301526108b2818461069d565b905092915050565b600060208201905081810360008301526108d381610707565b9050919050565b600060208201905081810360008301526108f38161076d565b9050919050565b600060e08201905061090f60008301846107d3565b92915050565b6000604051905081810181811067ffffffffffffffff8211171561093857600080fd5b8060405250919050565b600067ffffffffffffffff82111561095957600080fd5b602082029050919050565b6000819050919050565b600060029050919050565b600081519050919050565b6000602082019050919050565b600081905092915050565b600082825260208201905092915050565b600081905092915050565b600082825260208201905092915050565b60006109d4826109f1565b9050919050565b60008115159050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60005b83811015610a39578082015181840152602081019050610a1e565b83811115610a48576000848401525b50505050565b6000601f19601f8301169050919050565b610a68816109c9565b8114610a7357600080fd5b50565b610a7f816109db565b8114610a8a57600080fd5b50565b610a96816109e7565b8114610aa157600080fd5b50565b610aad81610a11565b8114610ab857600080fd5b5056fea2646970667358221220a0b4e697cb835f22a76f244d165840e5499ffd8c551c1d71fe740da31187890464736f6c63430006040033").to_vec();

      let method_data = hex!("1aad75c500000000000000000000000000000000000000000000000000000000000000408450410e16229672ebcb27bd1dc6d15b36f1bbbfb702fb683747e854ade08970000000000000000000000000000000000000000000000000000000000000004163b1d3e51e060c7457ce642b785eb8aca2ac7c086f55aa43d8b5f7a4f638ed2f4b235a48d313a0d60580b983d327ae77c41b878f4dd461a7d53d53a77112b74e1c00000000000000000000000000000000000000000000000000000000000000").to_vec();

      let result = exec(deployed_bytecode, method_data).unwrap();

      assert_eq!(result.len(), 32)
    }


    /// Executes a call to the following function.
    /// pragma solidity ^0.5.0;
    /// contract AddThree {
    ///   function addThree(uint256 a) public pure returns (uint256) {
    ///     return a + 3;
    ///   }
    /// }
    fn call_add_three(input: ethabi::Uint) -> ethabi::Uint {
        let code
            = hex!("608060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806308316796146044575b600080fd5b348015604f57600080fd5b50607960048036036020811015606457600080fd5b8101908080359060200190929190505050608f565b6040518082815260200191505060405180910390f35b600060038201905091905056fea165627a7a723058200e912ad05dca5252a91d1ce28dda0451a49092178c344ac1a40ccf9c9d5d46150029").to_vec();

        let method = ethabi::Function {
            name: "addThree".to_owned(),
            inputs: vec![ethabi::Param {
                name: "a".to_owned(),
                kind: ethabi::ParamType::Uint(256),
            }],
            outputs: vec![ethabi::Param {
                name: "".to_owned(),
                kind: ethabi::ParamType::Uint(256),
            }],
            constant: true,
        };
        // ABI encode with input of 4.
        let data = method.encode_input(&[ethabi::Token::Uint(input)]).unwrap();
        let result = exec(code, data).unwrap();

        assert_eq!(result.len(), 32);
        ethabi::Uint::from(&result[..32])
    }
}
